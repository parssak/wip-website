{"version":3,"sources":["frontend_components/UpdateMixBot.js","helper_classes/TrackFinder.js","helper_classes/Gateway.js","helper_classes/Analyzer.js","TrackSelector.js","Deck.js","TrackPlayer.js","Mixbot.js","frontend_components/Queue.js","Brain.js","frontend_components/MixConfig.js","App.js","reportWebVitals.js","index.js"],"names":["UpdateMixBot","details","dontCare","className","map","item","idx","key","id","style","flexGrow","onClick","window","open","intervalCall","makeRequest","path","p","a","axios","get","params","data","res","Gateway","currVersion","analysisObj","whitelistObj","referenceObj","trackID","playlistID","songID","songName","duration_ms","videoID","gateway","lastChosenID","fromDatabase","TrackFinder","trackDetail","foundSong","cantFind","newThought","useState","chosenVideoID","setChosenVideoID","songPath","setSongPath","createSearchQuery","artistNames","artists","forEach","e","thisName","name","push","videosSearch","search","getYoutubeList","response","getYoutubeVideo","searchQuery","then","songArtists","expectedDuration","addToWhitelist","getAudioPath","submitSong","clearInterval","album","images","useEffect","videoIDtoMP3","checkReferenceDB","result","checkWhitelistDB","findYoutubeID","console","log","thoughtType","NEUTRAL","setInterval","doesFileExist","getAudioLoaded","isLoaded","SectionType","Analyzer","songData","analyzedBars","sectionArray","sections","baselineLoudness","track","loudness","allBars","bars","songSections","barStartArray","bar","duration","barConfidence","confidence","barlength32","songDuration","num32Bar","calibrationArray","numCalibrationChunks","c","b","length","barRegion","start","end","drag","resize","computed","sectionType","is32length","comparisonLoudness","diff","beginpoint","endpoint","closestEnd","closest","closestBegin","offsetBegin","offsetEnd","sizeComparison","toPrecision","randomColor","goodForMix","analysisSection","begin","differential","sectionConfidence","conformedBegin","conformedEnd","oBegin","oEnd","is32","sectionColor","startingPos","startPos","tempo","songKey","needle","haystack","closeGrain","grainCloseness","grain","thisCloseness","Math","abs","MixType","currentMix","chosenPlaylist","analyzer","getMixText","TrackSelector","addToQueue","addMoreSongs","mixChosen","selectedPlaylist","listOfPlaylistFromAPI","playlist","setPlaylist","selectedTrack","listOfTracksFromAPI","tracks","setTracks","setTrackDetail","chosenMix","setChosenMix","changeChosen","random","chooseSong","useCallback","choiceSelections","selected","floor","trackAlreadyIn","trackInfo","filter","t","songURL","trackImage","youtubeVideoID","getAudioAnalysis","checkAnalysisDB","fetchedAnalysis","getSpotifyAnalysis","spotifyAnalysis","analyzeSong","body","analysis","tracklistSize","onSubmit","preventDefault","getPlaylist","tracksResponse","marginTop","alreadyDB","think","FAILURE","xhr","cache","mode","method","credentials","redirect","referrer","headers","isMasterPaused","Deck","props","state","pos","locked","scheduledDemise","currSec","playing","trackName","trackArtist","songArtist","audioCtx","AudioContext","audioSettings","gain","lowpassF","highpassF","high","mid","low","playbackRate","currSectionAnalysis","NaN","isBest","waveSurferOptions","container","waveformID","waveColor","cursorColor","hideScrollbar","normalize","height","barWidth","barHeight","barRadius","plugins","RegionPlugin","create","lastAdjustTime","synced","fadingOut","fadingIn","totalOffset","numSuccessful","numDropsPassed","playPause","bind","fadeOutSong","changeFilter","changeGain","reconnectAudio","handlePosChange","takeOutSong","normalizePlayback","this","waveform","WaveSurfer","on","error","load","thisSong","setPlaybackRate","prevProps","getVolume","recommendedVolume","pause","destroy","dummy","Audio","src","play","isPlaying","shouldSync","offset","getCurrentTime","adjustedOffset","skip","shouldRemove","otherPlaying","masterPlay","getPlaybackRate","newRate","lerp","deckName","isFinite","setVolume","lowpass","backend","ac","createBiquadFilter","frequency","value","type","Q","setState","lowpassNode","highpass","highpassNode","createGain","gainNode","setFilter","songAnalysis","analyzed","section","region","attributes","color","addRegion","hitBar","otherReady","getDuration","playOtherTrack","undefined","thisSection","comformedBegin","comformedEnd","resume","prepared","MIX","fadeInSong","amount","highpassAmount","min","setTimeout","finished","newVol","removeOther","songImage","url","alt","bpm","skipSong","Component","amt","deckname","lastTrackSet","mainTrack","deck1lastBar","deck2lastBar","deckOneGlow","deckTwoGlow","TrackPlayer","clock","setClock","deck1Song","setDeck1Song","deck2Song","setDeck2Song","deck1BPM","setDeck1BPM","deck2BPM","setDeck2BPM","deck1playback","setDeck1playback","deck2playback","setDeck2playback","deck1prepared","setDeck1prepared","deck2prepared","setDeck2prepared","deck1remove","setDeck1remove","deck2remove","setDeck2remove","deck1Playing","setDeck1Playing","deck2Playing","setDeck2Playing","deck1offset","setDeck1offset","deck2offset","setDeck2offset","setdeck1vol","setdeck2vol","loadTrackA","newSong","loadTrack","round","newvol","ratioPB","loadTrackB","ratio","deckOneReady","deckTwoReady","newClock","upcomingSongs","boxShadow","startTime","currentTime","textAlign","QueueBox","items","flexBasis","Brain","decisions","mixType","entryColor","SUCCESS","thought","uuidv4","display","MixConfig","hitPause","isPaused","setisPaused","tracklist","alreadyPlayed","nextSong","shift","currMixType","Mixbot","thoughts","setThoughts","setMixChosen","setMasterPlay","input","shouldShow","correctedArtists","artist","packageSong","App","updateAvailable","setUpdateAvailable","updateContent","setUpdateContent","checkForUpdate","newestVersion","needUpdate","version","newFeatures","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cc8a8f4c.chunk.js","sourcesContent":["import React from 'react'\n\nexport default function UpdateMixBot({ details, dontCare }) {\n    return (\n        <div className=\"update-mixbot\">\n            <h1>There is a new version of MixBot available!</h1>\n            <div className=\"update-content\">\n                {details &&\n                    details.map((item, idx) =>\n                        <div className={\"card\"} key={item.id + \"details\"} style={{ flexGrow: 1 }}>\n                            <p key={item.id + \"text details\"}>{item}</p>\n                        </div>)\n                }\n            </div>\n            \n            <div className=\"buttons\">\n                <button onClick={() => { window.open(\"https://www.parssak.com\"); }}>Download Here</button>\n                <button className=\"nothanks\" onClick={() => { dontCare()}}>No Thanks</button>\n            </div>\n\n        </div>\n    )\n}\n","import { useEffect, useState } from 'react';\nimport { thoughtType } from '../Mixbot';\nimport { Gateway } from './Gateway';\nconst liveServerBase = \"https://stark-reef-17924.herokuapp.com/\";\nlet gateway = new Gateway();\n/**\n * This class handles finding a track based on song name, artists, and duration\n * and calls the { foundSong } prop when a song has been found.\n */\n\n\nlet lastChosenID = \"\";\nlet fromDatabase = false;\nlet intervalCall;\n\nexport default function TrackFinder({ trackDetail, foundSong, cantFind, newThought }) {\n    const [chosenVideoID, setChosenVideoID] = useState(\"\");\n    const [songPath, setSongPath] = useState(\"\");\n\n\n    function createSearchQuery() {\n        let artistNames = [];\n        trackDetail.artists.forEach(e => {\n            const thisName = e.name;\n            if (thisName) {\n                artistNames.push(thisName)\n            }\n        });\n        let searchQuery = trackDetail.name + \" by \" + artistNames[0];\n        return searchQuery;\n    }\n\n\n    async function videosSearch(search) {\n        const response = await gateway.getYoutubeList(search, trackDetail.duration_ms)\n        return response;\n    }\n\n    /**\n     * Searches YouTube for song using search query, breaks when found is song\n     * @param searchQuery\n     * @returns {Promise<void>}\n     */\n    async function getYoutubeVideo(searchQuery) {\n        videosSearch(searchQuery).then(async e => {\n            if (e.data) {\n                setChosenVideoID(e.data);\n            } else {\n                let whitelistObj = {\n                    songID: trackDetail.id,\n                    songName: trackDetail.name,\n                    songArtists: trackDetail.artists,\n                    expectedDuration: trackDetail.duration_ms,\n                }\n                await gateway.addToWhitelist(whitelistObj);\n                cantFind(false);\n            }\n        })\n    }\n\n    /**\n     * This effect triggers when the chosenVideoID is\n     * found, and then get the URL for mp3 download\n     *\n     * Since this effect gets called over once for the\n     * same video being found sometimes, it will not\n     * convert the video to mp3 if it has already been\n     * called once for this current song\n     * >> “ \"lastChosenID === \"\" ”\n     */\n    useEffect(() => {\n        if (chosenVideoID && lastChosenID === \"\") {\n            lastChosenID = chosenVideoID;\n            videoIDtoMP3(chosenVideoID);\n        }\n    }, [chosenVideoID])\n\n    useEffect(() => {\n        async function findYoutubeID() {\n            const result = await gateway.checkReferenceDB(trackDetail.id);\n            lastChosenID = \"\";\n            if (result === \"\") {\n                const whitelistResult = await gateway.checkWhitelistDB(trackDetail.id);\n                if (whitelistResult === \"\") {\n                    fromDatabase = false;\n                    const search = createSearchQuery();\n                    await getYoutubeVideo(search);\n                } else {\n                    cantFind(true);\n                }\n            } else {\n                fromDatabase = true;\n                setChosenVideoID(result.videoID);\n            }\n        }\n        if (trackDetail) findYoutubeID();\n    }, [trackDetail]);\n\n    async function videoIDtoMP3(videoID) {\n        // let recievedPath = null;\n        gateway.getAudioPath(videoID).then(res => {\n            setSongPath(liveServerBase + videoID + \".mp3\");\n        })\n    }\n\n    useEffect(() => {\n        if (songPath !== \"\" && !intervalCall) {\n            console.log(\"fetching\", trackDetail);\n            newThought(`Getting ${trackDetail.name} by ${trackDetail.artists[0].name}`, thoughtType.NEUTRAL);\n            intervalCall = setInterval(async function () {\n                let res = await doesFileExist(chosenVideoID);\n                if (res) {\n                    submitSong();\n                }\n            }, 7000)\n        } else {\n            console.log(\"didn't call the interval\", songPath, intervalCall);\n        }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [songPath]);\n\n    function submitSong() {\n        clearInterval(intervalCall);\n        intervalCall = null;\n        setSongPath(\"\");\n        foundSong(trackDetail.name, trackDetail.artists, trackDetail.duration_ms, songPath, trackDetail.id, trackDetail.album.images[1], chosenVideoID, fromDatabase); // ! CHANGED THIS FROM PARAM TO CHOSENVIDEOID\n    }\n    return null;\n}\n\n\nasync function doesFileExist(videoID) {\n    let res = await gateway.getAudioLoaded(videoID);\n    return res.isLoaded;\n}","import axios from 'axios';\nconst serverBaseURL = 'https://stark-reef-17924.herokuapp.com/';\n\nconst makeRequest = async (path, p) => {\n    const res = await axios.get(serverBaseURL + path, {\n        params: {\n            data: p\n        }\n    })\n    return res.data;\n}\n\nexport class Gateway {\n    async checkForUpdate(currVersion) {\n        return await makeRequest('checkUpdate', { data: currVersion })\n    }\n\n    //*** ADDING DB*/\n    async addToAnalysis(analysisObj) {\n        return await makeRequest('addAnalysis', { data: analysisObj })\n    }\n\n    async addToWhitelist(whitelistObj) {\n        return await makeRequest('addWhitelist', { data: whitelistObj })\n    }\n\n    async addToReference(referenceObj) {\n        return await makeRequest('addReference', { data: referenceObj })\n    }\n    \n    //*** GETTING DB */\n    async checkReferenceDB(trackID) {\n        return await makeRequest('checkReference', { data: trackID })\n    }\n\n    async checkAnalysisDB(trackID) {\n        return await makeRequest('checkAnalysis', { data: trackID })\n    }\n\n    async checkWhitelistDB(trackID) {\n        return await makeRequest('checkWhitelist', { data: trackID })\n    }\n    \n    //*** SPOTIFY */\n    async getPlaylist(playlistID) {\n        return await makeRequest('playlist', { playlistID: playlistID })\n    }\n\n    async getSpotifyAnalysis(songID) {\n        return await makeRequest('analysis', { songID: songID })\n    }\n\n    //*** YOUTUBE */\n    async getYoutubeList(songName, duration_ms) {\n        return await makeRequest('search-yt', { songName: songName, duration_ms: duration_ms })\n    }\n\n    //*** AUDIO */\n    \n    // Returns path extension for the audio\n    async getAudioPath(videoID) { \n        return await makeRequest('getMP3', { id: videoID })\n    }\n    // Returns true or false if audio finished loading\n    async getAudioLoaded(videoID) {\n        return await makeRequest('getLoaded', { id: videoID })\n    }\n\n}","export const SectionType = {\n    DROP: 1,\n    REGULAR: 2,\n    COMEDOWN: 3,\n    BEGIN: 4,\n    UNSURE: 5\n}\n\nexport class Analyzer {\n    constructor() {\n        console.log(\"new analyzer created\");\n    }\n\n    /**\n     * Returns:\n     * {\n     *      songSections: All sections of the song, tagged with what they are\n     *      bars: Bars estimated through the data, used for syncing\n     *      startPos: Section the song should start\n     * }\n     */\n    analyzeSong(songData) {\n        console.log(\"analyzing data.\");\n        let analyzedBars = [];\n        let sectionArray = songData.sections;\n        let baselineLoudness = songData.track.loudness;\n        let allBars = songData.bars;\n        \n\n        let songSections = [];\n        // let currSection = 0;\n\n        // song analysis variables\n        // let numDrops = 0;\n        // let mostConfidentDrop = 0;\n\n        // let numComedowns = 0;\n        // let mostConfidentComedown = 0;\n\n        // get an array of when all bars start\n        let barStartArray = []\n\n        let bar = allBars[0].duration;\n        let barConfidence = 0;\n        allBars.forEach(e => {\n            if (e.confidence > barConfidence) {\n                bar = e.duration;\n                barConfidence = e.confidence;\n            }\n        })\n        let barlength32 = bar * 2;\n        let songDuration = songData.track.duration;\n\n        let num32Bar = ((songDuration) / barlength32);\n\n        for (let a = 0; a <= num32Bar; a++) {\n            barStartArray.push(((a) * barlength32));\n        }\n\n        let calibrationArray = [];\n\n        let numCalibrationChunks = (songDuration) / bar;\n\n        for (let c = 0; c <= numCalibrationChunks; c++) {\n            calibrationArray.push(((c) * bar));\n        }\n\n\n        for (let b = 0; b < calibrationArray.length - 1; b++) {\n            // let barColor = (b % 2 ? \"rgba(255, 60, 54,0.05)\" : \"rgba(46, 255, 154,0.05)\");\n            let barRegion = {\n                start: calibrationArray[b],\n                end: calibrationArray[b + 1],\n                // color: barColor,\n                drag: false,\n                resize: false,\n                computed: {}\n            };\n            analyzedBars.push(barRegion); \n            // this.waveform.addRegion(barRegion);\n        }\n\n        sectionArray.forEach(e => {\n            // currSection++;\n            let sectionType = SectionType.REGULAR;\n            let is32length = false;\n\n            let comparisonLoudness = (e.loudness - baselineLoudness) / baselineLoudness;\n\n            // IF BEGINNING OF SONG\n            if (songSections.length === 0) {\n                sectionType = SectionType.BEGIN;\n            }\n\n            // IF LOUD === DROP\n            if (comparisonLoudness < 0) {\n                sectionType = SectionType.DROP;\n            }\n\n            // IF LAST SONG WAS DROP AND DIFFERENTIAL OF THIS IS NEGATIVE === COMEDOWN\n            let diff = 0;\n            if (songSections.length > 0) {\n                diff = songSections[songSections.length - 1].computed.comparisonLoudness - comparisonLoudness;\n                if (songSections[songSections.length - 1].sectionType === SectionType.DROP) {\n                    if (sectionType === SectionType.DROP) {\n                        sectionType = SectionType.UNSURE;\n                    } else {\n                        sectionType = SectionType.COMEDOWN\n                    }\n                }\n            }\n\n            let beginpoint = e.start;\n            let endpoint = e.start + e.duration;\n            let closestEnd = this.closest(endpoint, barStartArray);\n            let closestBegin = this.closest(beginpoint, barStartArray);\n            let offsetBegin = closestBegin - beginpoint;\n            let offsetEnd = closestEnd - endpoint;\n            let acceptedConformEnd = false;\n            let acceptedConformBegin = false;\n\n            beginpoint = closestBegin;\n            endpoint = closestEnd;\n\n\n            let sizeComparison = ((endpoint - beginpoint) / barlength32).toPrecision(2); // checks if section is of calculated 32bar length\n            if (sizeComparison % 1) {\n                is32length = true;\n            }\n\n            let randomColor = 'rgba(162,254,231,0.3)';\n            switch (sectionType) {\n                case \"\":\n                    break;\n                case SectionType.BEGIN:\n                    // toLoop = true;\n                    randomColor = 'rgba(50,255,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(100,255,55,0.3)';\n                    }\n                    break;\n                case SectionType.DROP:\n                    randomColor = 'rgba(237,61,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(255,31,105,0.3)';\n                    }\n                    break;\n                case SectionType.COMEDOWN:\n                    randomColor = 'rgba(123,215,255,0.3)'\n                    if (is32length) {\n                        randomColor = 'rgba(50,150,255,0.3)'\n                    }\n                    break;\n                case SectionType.UNSURE:\n                    randomColor = 'rgba(34,1,255,0.2)'\n                    if (is32length) {\n                        randomColor = 'rgba(0,255,150,0.2)'\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            let goodForMix = false;\n            if (sectionType !== SectionType.DROP) {\n                if (comparisonLoudness > 0 && comparisonLoudness < 0.1) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                } else if (sectionType === SectionType.BEGIN) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                }\n            }\n            // ! THIS IS FOR UI PURPOSES REMOVE THIS WHEN TESTING\n            randomColor = 'rgba(0, 0, 0, 0)';\n\n            let analysisSection = {\n                sectionType: sectionType,\n                begin: beginpoint,\n                endpoint: endpoint,\n                computed: {\n                    comparisonLoudness: comparisonLoudness,\n                    differential: diff,\n                    sectionConfidence: e.confidence,\n                    conformedBegin: acceptedConformBegin,\n                    conformedEnd: acceptedConformEnd,\n                    oBegin: offsetBegin,\n                    oEnd: offsetEnd\n                },\n                sizeComparison: sizeComparison,\n                is32: is32length,\n                sectionColor: randomColor,\n                goodForMix: goodForMix\n            }\n            songSections.push(analysisSection);\n        })\n\n        let startingPos = 0; // TODO PASS THIS OUT\n\n        if (songSections.length > 2) {\n            // console.log(\"sec1:\", songSections[0].sizeComparison, \"sec2:\", songSections[1].sizeComparison);\n            // console.log(\"sec1:\", songSections[0].is32, \"sec2:\", songSections[1].is32);\n            if ((songSections[0].sizeComparison === 4) || (songSections[0].sizeComparison === 2 && songSections[1].sizeComparison === 2)) {\n                    startingPos= 0\n            } else if (songSections[0].sizeComparison === 2.0 && songSections[1].sizeComparison % 4 === 0) { // todo make this if songSections[1].sizeComparison is a multiple of 4\n                // console.log(\"mult of 4?\", songSections[1].sizeComparison % 4);\n                startingPos = songSections[0].endpoint;  \n            } \n        }\n\n        let finalAnalysis = {\n            songSections: songSections,\n            bars: calibrationArray,\n            startPos: startingPos,\n            tempo: songData.track.tempo,\n            loudness: baselineLoudness,\n            songKey: songData.track.key\n        }\n\n        return finalAnalysis;\n    }\n\n\n    closest(needle, haystack) {\n        let closeGrain = 100000000000000;\n        let grainCloseness = 100000000000000;\n        haystack.forEach(grain => {\n            let thisCloseness = Math.abs(needle - grain)\n            if (Math.abs(needle - grain) < grainCloseness) {\n                grainCloseness = thisCloseness;\n                closeGrain = grain;\n            }\n        })\n        return closeGrain;\n    }\n}","import React, { useState, useEffect, useCallback } from 'react';\nimport TrackFinder from \"./helper_classes/TrackFinder\";\nimport { thoughtType, trackAlreadyIn, tracklistSize } from \"./Mixbot\";\nimport { Gateway } from './helper_classes/Gateway';\nimport { Analyzer } from './helper_classes/Analyzer';\n/**\n * \n * * 1. (playlistSearchClicked) Choose Playlist\n * * 2. (chooseSong) Chooses song\n *                     - Check if song hasn't been already played\n * *    Keep choosing songs until !addMoreSongs\n * * 3. <TrackFinder/> For each song, find YouTube video ID for song\n *                     - If can't find song, remove song from options and try again\n *                     - If found song, call addSongToTracklist\n * * 4. (addSongToTracklist) Check if song still hasn't been added to tracklist\n *                     - If has, repeat process\n *                     - If hasn't, get audio analysis for song\n * * 5. (getAudioAnalysis) Get audio analysis, then add it to tracklist\n */\nconst MixType = {\n    EURO_HOUSE: 1,\n    CHILL_HOUSE: 2,\n    TECH_HOUSE: 3,\n}\n\nlet currentMix = null; // meant to be a mixType\nconst euroHouseMix_1 = \"2818tC1Ba59cftJJqjWKZi\";\nconst euroHouseMix_2 = \"1fWDDXepy50hFXLhwGR5xP\";\nconst chillMix_1 = \"52yAobXW9CokfKnLhe3C8Z\";\nconst chillMix_2 = \"6el7EnAXJJ2kvnoBDvWXvk\";\nconst techHouseMix_1 = \"7HRYveKYzLJFqb1PTJejoL\";\n\nlet chosenPlaylist = null;\n\nlet gateway = new Gateway();\nlet analyzer = new Analyzer();\n// let numChosen = 0;\n// let numLimit = 100;\n\nfunction getMixText() {\n    switch (currentMix) {\n        case MixType.EURO_HOUSE:\n            return \"Euro House Mix\";\n        case MixType.TECH_HOUSE:\n            return \"Tech House Mix\";\n        case MixType.CHILL_HOUSE:\n            return \"Chill House Mix\";\n        default:\n            break;\n    }\n}\nfunction TrackSelector({ addToQueue, addMoreSongs, newThought, mixChosen }) {\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: null, listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n    const [chosenMix, setChosenMix] = useState(false);\n\n    function changeChosen(playlist) {\n        if (playlist === 1) { // euro house\n            currentMix = MixType.EURO_HOUSE;\n            chosenPlaylist = Math.random() > 0.5 ? euroHouseMix_1 : euroHouseMix_2;\n        } else if (playlist === 2) {\n            currentMix = MixType.CHILL_HOUSE;\n            chosenPlaylist = Math.random() > 0.5 ? chillMix_1 : chillMix_2;\n        } else {\n            currentMix = MixType.TECH_HOUSE;\n            chosenPlaylist = techHouseMix_1;\n        }\n\n        setPlaylist({ selectedPlaylist: chosenPlaylist });\n        setChosenMix(true);\n    }\n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        // numChosen = 0;\n        gateway.getPlaylist(playlist.selectedPlaylist).then(tracksResponse => {\n            console.log('got tracks', tracksResponse);\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse\n            })\n\n            mixChosen(getMixText());\n        });\n    }\n\n    const chooseSong = useCallback((choiceSelections) => {\n        let selected = choiceSelections[Math.floor(Math.random() * (choiceSelections.length - 1))];\n        if (!trackAlreadyIn(selected.track.id)) {\n            const currentTracks = [...tracks.listOfTracksFromAPI];\n            const trackInfo = currentTracks.filter(t => t.id === selected.id);\n            setTrackDetail(trackInfo[0]);\n        }\n    });\n\n    useEffect(() => {\n        console.log(\"[effect] track selector\");\n        if (tracks.listOfTracksFromAPI.length > 0) {\n            if (trackDetail == null && addMoreSongs) {\n                console.log(\"FINDING ANOTHER SONG\");\n                chooseSong(tracks.listOfTracksFromAPI)\n            }\n            else {\n                console.log(\"did not call to choose more songs\", trackDetail, addMoreSongs);\n            }\n        } else {\n            console.log(\"flopped!!!!!!\");\n        }\n    }, [tracks, trackDetail, addMoreSongs, chooseSong])\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage, youtubeVideoID, fromDatabase) {\n        if (!trackAlreadyIn(trackID))\n            await getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase);\n        else\n            setTrackDetail(null);\n    }\n\n    const getAudioAnalysis = async (id, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase) => {\n        let fetchedAnalysis = await gateway.checkAnalysisDB(id);\n        if (!fetchedAnalysis) {\n            let spotifyAnalysis = await gateway.getSpotifyAnalysis(id);\n            fetchedAnalysis = analyzer.analyzeSong(spotifyAnalysis.body)\n            let dbAnalysis = {\n                songID: id,\n                songName: songName,\n                analysis: fetchedAnalysis\n            }\n            fetchedAnalysis = dbAnalysis;\n        }\n        addToQueue(songName, songArtists, duration, songURL, fetchedAnalysis, trackImage, id, youtubeVideoID, fromDatabase);\n        setTrackDetail(null);\n    }\n\n    const couldntBeFound = (alreadyDB) => {\n        if (!alreadyDB) {\n            const think = \"Unable to add \" + trackDetail.name;\n            newThought(think, thoughtType.FAILURE);\n        }\n        setTrackDetail(null);\n    }\n\n    return (\n        <div className=\"selector-wrapper\">\n            {chosenMix ? <h1>{getMixText()}</h1> : <h1>Select a mix</h1>}\n            <div className=\"playlist-select\">\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(1)}>EURO HOUSE</button>}\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(2)}>CHILL HOUSE</button>}\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(3)}>TECH HOUSE</button>}\n            </div>\n\n            <form onSubmit={playlistSearchClicked}>\n                {chosenMix && tracklistSize() === 0 && <button className=\"begin-mix\">Begin mix</button>}\n                <div style={{ marginTop: \"4em\" }}>\n                    <TrackFinder\n                        trackDetail={trackDetail}\n                        foundSong={addSongToTracklist}\n                        cantFind={couldntBeFound}\n                        newThought={newThought}\n                    />\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","import React, { Component } from 'react';\nimport WaveSurfer from 'wavesurfer.js';\nimport RegionPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport './css_files/Deck.scss';\nimport { SectionType } from './helper_classes/Analyzer';\nimport { thoughtType } from './Mixbot';\n\nlet xhr = { cache: 'default', mode: 'cors', method: 'GET', credentials: 'same-origin', redirect: 'follow', referrer: 'client', headers: [{ 'Access-Control-Allow-Origin': '*' }] };\nlet isMasterPaused = false;\n\nexport default class Deck extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            pos: 0,\n            locked: false,\n            scheduledDemise: false,\n            currSec: \"NOT PLAYING\",\n            playing: false,\n            trackName: this.props.songName,\n            trackArtist: this.props.songArtist,\n            audioCtx: new AudioContext(),\n            audioSettings: {\n                gain: 1,\n                lowpassF: 11000,\n                highpassF: 0,\n                high: 1,\n                mid: 1,\n                low: 1,\n                playbackRate: this.props.playbackRate\n            },\n            currSectionAnalysis: {\n                begin: NaN,\n                endpoint: NaN,\n                comparisonLoudness: NaN,\n                differential: NaN,\n                sectionConfidence: NaN,\n                conformedBegin: NaN,\n                conformedEnd: NaN,\n                oBegin: NaN,\n                oEnd: NaN,\n                sectionColor: `rgb(255,255,255)`,\n                goodForMix: false,\n                isBest: false\n            },\n            startingPos: 0\n        };\n\n        this.waveSurferOptions = {\n            container: `#${this.props.waveformID}`,\n            waveColor: \"#ffffff\",\n            cursorColor: \"tomato\",\n            hideScrollbar: true,\n            normalize: true,\n            height: 70,\n            barWidth: 1,\n            barHeight: 0.5, // the height of the wave\n            barRadius: 2,\n            plugins: [\n                RegionPlugin.create(),\n            ],\n            xhr: xhr\n        }\n\n        this.lastAdjustTime = 0;\n        this.synced = false;\n        this.fadingOut = false;\n        this.fadingIn = false;\n        this.totalOffset = 0;\n        this.numSuccessful = 0;\n        this.numDropsPassed = 0;\n\n        this.playPause = this.playPause.bind(this);\n        this.fadeOutSong = this.fadeOutSong.bind(this);\n        this.changeFilter = this.changeFilter.bind(this);\n        this.changeGain = this.changeGain.bind(this);\n        this.reconnectAudio = this.reconnectAudio.bind(this);\n        this.handlePosChange = this.handlePosChange.bind(this);\n        this.takeOutSong = this.takeOutSong.bind(this);\n        this.normalizePlayback = this.normalizePlayback.bind(this);\n    }\n\n    componentDidMount() {\n        this.waveform = WaveSurfer.create(this.waveSurferOptions);\n\n        this.waveform.on('error', e => {\n            console.error(e);\n        })     \n        this.waveform.load(this.props.thisSong);\n        this.waveform.setPlaybackRate(this.props.playbackRate);\n        this.reconnectAudio();\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.waveform.getVolume() < this.props.recommendedVolume &&\n            !this.fadingIn &&\n            !this.fadingOut) {\n                // do nothing\n                // this.waveform.setVolume(this.props.recommendedVolume);\n        }\n        \n        if (this.props.thisSong !== prevProps.thisSong) { \n            this.waveform.pause();\n            this.synced = false;\n            this.numSuccessful = 0;\n            this.totalOffset = 0;\n            this.fadingOut = false;\n            this.fadingIn = false;\n            this.numDropsPassed = 0;\n\n            this.waveform.destroy();\n            this.waveform = WaveSurfer.create(this.waveSurferOptions);\n            \n            this.waveform.on('error', e => {\n                //console.log(\"hit error:\", e);\n            })\n\n            let dummy = new Audio(this.props.thisSong);\n            this.waveform.load(dummy.src);\n            this.waveform.setPlaybackRate(this.props.playbackRate);\n\n            this.reconnectAudio();\n        } \n\n        if (this.state.audioCtx.state !== 'suspended') {\n            if (this.props.play !== this.waveform.isPlaying()) {\n                if (!this.props.play) {\n                    //console.log(\"~~~ SHOULD BE PAUSED NGL ~~~\");\n                    this.waveform.pause();\n                } else {\n                    this.playPause();\n                }\n            }\n        }\n\n        if (!this.props.shouldSync) {\n            this.synced = true; // If this is the main track, don't sync it\n            this.normalizePlayback();\n            \n        }\n\n        // If the offset between tracks is under 0.1 seconds and this is playing, this track is succesful\n        // ! The margin of error of 0.1s is needed due to timing issues with WebAudio\n        if (Math.abs(this.props.offset) < 0.1 && this.waveform.isPlaying()) {\n            this.numSuccessful++;\n            if (Math.abs(this.props.offset) < 0.05) this.numSuccessful++;\n            if (this.numSuccessful >= 3) {\n                this.synced = true;\n            }\n        }\n\n        /**\n         * IF:\n         *  1) New offset passed in\n         *  2) It has been over 5 seconds since the last time it was adjusted\n         */\n        if (this.props.offset !== prevProps.offset &&\n            this.waveform.getCurrentTime() - this.lastAdjustTime > 5 &&\n            Math.abs(this.props.offset) >= 0.05 &&\n            !this.synced) {\n            this.numSuccessful = 0;\n            //console.log(this.props.deckName, \"-> about to sync\");\n            if (this.waveform.getCurrentTime() + this.props.offset > 1 && this.props.offset != 0) {\n                this.lastAdjustTime = this.waveform.getCurrentTime();\n                let adjustedOffset = this.props.offset;\n                this.totalOffset = this.props.offset;\n                let desiredTime = this.waveform.getCurrentTime() + this.props.offset;\n                this.waveform.pause();\n                this.waveform.skip(adjustedOffset);\n                this.waveform.playPause();\n                //console.log(\"%%%   \", this.props.deckName, \" now we are at:\", this.waveform.getCurrentTime(), \"difference is:\", desiredTime - this.waveform.getCurrentTime(), \"offset diff:\", (this.props.offset - desiredTime - this.waveform.getCurrentTime()));\n            } else {\n                //console.log(this.props.deckName, \"-> didn't sync \");\n            }\n        }\n\n        if (this.props.shouldRemove && !this.fadingOut && !this.shouldSync && this.props.otherPlaying) {\n            this.takeOutSong();\n        }\n\n        if (this.props.masterPlay !== prevProps.masterPlay) {\n            if (this.props.masterPlay) {\n                this.waveform.pause();\n                isMasterPaused = true;\n            } else {\n                if (this.waveform.isPlaying() !== this.props.play) {\n                    this.waveform.play();\n                } else {\n                    isMasterPaused = false;\n                }\n            }\n        }\n    }\n\n    normalizePlayback() {\n        if (this.waveform.getPlaybackRate() !== 1) {\n            let newRate = lerp(this.waveform.getPlaybackRate(), 1, 0.1, this.props.deckName);\n            if (isFinite(newRate)) this.waveform.setVolume(newRate);\n            if (Math.abs(1 - this.waveform.getPlaybackRate()) < 0.1) this.waveform.setPlaybackRate(1);\n            else this.normalizePlayback();\n        }\n    }\n\n    reconnectAudio() {\n        // LOWPASS\n        let lowpass = this.waveform.backend.ac.createBiquadFilter();\n        lowpass.frequency.value = this.state.audioSettings.lowpassF || 11000;\n        lowpass.type = \"lowpass\";\n        lowpass.Q.value = 5;\n        this.setState({\n            lowpassNode: lowpass\n        });\n\n        // HIGHPASS\n        let highpass = this.waveform.backend.ac.createBiquadFilter();\n        highpass.frequency.value = this.state.audioSettings.highpassF || 0;\n        highpass.type = \"highpass\";\n        highpass.Q.value = 5;\n        this.setState({\n            highpassNode: highpass\n        });\n\n        // GAIN\n        let gain = this.waveform.backend.ac.createGain();\n        gain.value = this.state.audioSettings.gain || 0.01;\n        this.setState({\n            gainNode: gain\n        });\n        this.waveform.backend.setFilter(lowpass, highpass);\n        if (this.props.songAnalysis !== 'NOTFOUND') {\n            let analyzed = this.props.songAnalysis.analysis.songSections;\n            if (!analyzed) {\n                console.log(\"error!!\");\n                console.log(this.props);\n            }\n            if (!analyzed) {\n                console.log(\"NO ANALYZED!!\", this.props)\n            }\n            \n            analyzed.forEach(section => {\n                let region = {\n                    start: section.begin,\n                    end: section.endpoint,\n                    attributes: section.computed,\n                    data: section,\n                    color: section.sectionColor,\n                    drag: false,\n                    resize: false,\n                }\n                this.waveform.addRegion(region);\n            })\n\n            let bars = this.props.songAnalysis.analysis.bars;\n            bars.forEach(b => {\n                this.waveform.addRegion(b);\n            })\n            this.setState({\n                startingPos: this.props.songAnalysis.startPos\n            })\n        }\n        this.waveform.on('region-in', e => {\n            this.props.hitBar();\n            // console.log(\">>>> HIT BAR : DIFF\", e.data.computed.differential, \"COMPLOUD\", e.data.computed.comparisonLoudness);\n            if (e.data.computed.differential < 0) {\n                if (this.props.otherReady && (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.4)) {\n                    this.props.playOtherTrack();                                                 \n                    //console.log(this.props.deckName, \"good mixing spot\");\n                }\n            }\n            if (e.data.sectionType !== undefined) { // has data!\n                if (e.data.sectionType === SectionType.DROP) {\n                    this.numDropsPassed++;\n                }\n            }\n        })\n\n        this.waveform.on('region-out', e => {\n            let thisSection = e.data;\n            let computed = thisSection.computed;\n            if (computed) {\n                this.setState({\n                    currSec: thisSection.sectionType,\n                    currSectionAnalysis: {\n                        begin: thisSection.begin,\n                        endpoint: thisSection.endpoint,\n                        comparisonLoudness: computed.comparisonLoudness,\n                        differential: computed.differential,\n                        sectionConfidence: computed.sectionConfidence,\n                        conformedBegin: computed.comformedBegin,\n                        conformedEnd: computed.comformedEnd,\n                        oBegin: computed.oBegin,\n                        oEnd: computed.oEnd,\n                        sectionColor: thisSection.sectionColor,\n                        goodForMix: thisSection.goodForMix,\n                        isBest: thisSection.isBest,\n                        sizeComparison: thisSection.sizeComparison,\n                        is32: thisSection.is32\n                    }\n                })\n                //console.log(this.props.deckName, \" HAS FINISHED\", this.waveform.getCurrentTime() / this.waveform.getDuration(), \"OF ITS SONG\");\n                if (this.props.otherReady && (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.4)) {\n                    if ((thisSection.sectionType === SectionType.DROP && this.numDropsPassed > 0) || thisSection.sectionType === SectionType.COMEDOWN) {\n                        this.props.playOtherTrack();                                                 \n                    } else if (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.7) {\n                        this.props.playOtherTrack();\n                    }\n                }\n            } else {\n                this.props.hitBar();\n            }\n        });\n\n        this.waveform.on('ready', e => {\n            //console.log(\"------ READY TO GO! 1 ------\");\n            this.state.audioCtx.resume();\n            if (!this.waveform.isPlaying()) {\n                this.playPause();\n                this.props.prepared();\n            }\n            this.waveform.setVolume(0.01);\n        });\n\n        this.waveform.on('play', e => {\n            \n            if (this.props.play) {\n                // console.log(this.props.deckName, \" JUST STARTED PLAYING GONNA FADE IT IN NOW OK\");\n                if (isMasterPaused) {\n                    console.log(\"was a master pause\");\n                    isMasterPaused = false;\n                } else {\n                    this.waveform.setVolume(0.01);\n                    let think = \"Fading in \" + this.props.deckName;\n                    this.props.newThought(think, thoughtType.MIX);\n                    this.fadeInSong();\n                }\n            }\n            \n        })\n\n    }\n\n    takeOutSong() {\n        this.fadeOutSong();\n        let think = \"Fading out \" + this.props.deckName;\n        this.props.newThought(think, thoughtType.MIX);\n    }\n\n    playPause() {\n        // check if context is in suspended state (autoplay policy)\n        if (this.state.audioCtx.state === 'suspended') {\n            this.state.audioCtx.resume();\n\n        }\n        this.waveform.play(this.state.startingPos);\n        if (this.state.playing !== this.waveform.isPlaying()) {\n            this.setState({\n                playing: this.waveform.isPlaying()\n            });\n        }\n    }\n\n    changeFilter(amount) {\n        if (amount <= 14000) {\n            this.state.audioSettings.lowpassF = amount;\n            this.state.lowpassNode.frequency.value = amount;\n        } else if (amount >= 20000) {\n            let highpassAmount = amount - 20000;\n            this.state.audioSettings.highpassF = highpassAmount;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        } else {\n            this.state.audioSettings.lowpassF = 30000;\n            this.state.lowpassNode.frequency.value = this.state.audioSettings.lowpassF;\n            this.state.audioSettings.highpassF = 0;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        }\n    }\n\n    changeGain(amount) {\n        this.setState({\n            audioSettings: {\n                gain: (amount / 100).toPrecision(2)\n            }\n        })\n    }\n\n    handlePosChange(e) {\n        this.setState({\n            pos: e\n        });\n    }\n\n    fadeOutSong() {\n        this.fadingOut = true;\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), 0, Math.min(this.waveform.getVolume() / 3), 0.1, this.props.deckName));\n        this.state.lowpassNode.frequency.value -= (this.state.lowpassNode.frequency.value / 10);\n        if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() > 0.01) {\n            setTimeout(() => {\n                this.fadeOutSong();\n            }, 1000);\n        } else {\n            //console.log(\">>>>>>>   >>> \", this.props.deckName, \" FADED OUT_________\");\n            this.fadingOut = false;\n            this.waveform.setVolume(0);\n            this.waveform.pause();\n            this.props.finished();\n        }\n    }\n\n    fadeInSong() {\n        this.fadingIn = true;\n        let newVol = lerp(this.waveform.getVolume(), this.props.recommendedVolume, Math.min((this.waveform.getVolume()) / 4), 0.03, this.props.deckName);\n        if (isFinite(newVol)) {\n            if (newVol >= this.props.recommendedVolume) this.waveform.setVolume(this.props.recommendedVolume);\n            else this.waveform.setVolume(newVol);\n        }\n        \n        if (this.waveform.getVolume() < this.props.recommendedVolume - 0.05) {   // TODO TWEAK THIS BASED ON IF MAIN TRACK OR NOT\n            setTimeout(() => {\n                this.fadeInSong();\n            }, 1000);\n        } else {\n            //console.log(\">>>>>>>  !!!  >>> \", this.props.deckName, \" FADED IN_________!!!!\");\n            this.fadingIn = false;\n            this.waveform.setVolume(this.props.recommendedVolume);\n            this.props.removeOther();\n        }\n    }\n\n    skipSong() {\n        this.takeOutSong();\n        this.props.playOtherTrack();\n    }\n\n    render() {\n        return (\n            <>\n                <div className={\"deck\"}>\n                    \n                    <img src={this.props.songImage.url} alt=\"\" />\n                    <div className={\"deck-content\"}>\n                        <div className={\"deck-text\"}>\n                            {this.props.songName !== \"\" && <h2>{this.props.songName}</h2>}\n                            {this.props.songName !== \"\" && <h3>{this.props.songArtist}</h3>}\n                        </div>\n                        <div className={\"deck-text\"}>\n                            <h4>{this.props.bpm} BPM</h4>\n                            <button onClick={() => this.skipSong()}>SKIP SONG</button>\n                        </div>\n                        <div id={`${this.props.waveformID}`} />\n                    </div>\n                    \n                    {/* <Knob size={70} numTicks={70} degrees={260} min={0} max={100} value={50} color={true} onChange={this.changeGain} /> */}\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={1000} max={30000} value={15000} color={true} onChange={this.changeFilter} /> */}\n                </div>\n            </>\n        );\n    }\n}\n\nfunction lerp(start, end, amt, deckname) {\n    return (1 - amt) * start + amt * end\n}\n\n","import React, { useEffect, useState } from 'react';\nimport Deck from \"./Deck\";\nimport './css_files/Queue.scss';\nimport { loadTrack, nextSongInQueue } from \"./Mixbot\";\n\nlet deck1startTime = 0;\nlet deck2startTime = 0;\n\nlet lastTrackSet = 0;\nlet mainTrack = 0;\n\nlet deck1lastBar = 0;\nlet deck2lastBar = 0;\n\nlet deckOneGlow = 9;\nlet deckTwoGlow = 9;\n\nlet equalizedGainVal = -10;\n\nexport default function TrackPlayer({ newThought, masterPlay }) {\n    const [clock, setClock] = useState();\n\n    const [deck1Song, setDeck1Song] = useState('');\n    const [deck2Song, setDeck2Song] = useState('');\n\n    const [deck1BPM, setDeck1BPM] = useState(0);\n    const [deck2BPM, setDeck2BPM] = useState(0);\n\n    const [deck1playback, setDeck1playback] = useState(1);\n    const [deck2playback, setDeck2playback] = useState(1);\n\n    const [deck1prepared, setDeck1prepared] = useState(false);\n    const [deck2prepared, setDeck2prepared] = useState(false);\n\n    const [deck1remove, setDeck1remove] = useState(false);\n    const [deck2remove, setDeck2remove] = useState(false);\n\n    const [deck1Playing, setDeck1Playing] = useState(false);\n    const [deck2Playing, setDeck2Playing] = useState(false);\n\n    const [deck1offset, setDeck1offset] = useState(0);\n    const [deck2offset, setDeck2offset] = useState(0);\n\n    // const [deck1gain, setDeck1Gain] = useState(null); // actual volumes in db\n    // const [deck2gain, setDeck2Gain] = useState(null);\n\n    const [deck1vol, setdeck1vol] = useState(1); // relative vol 0 -1\n    const [deck2vol, setdeck2vol] = useState(1);\n\n    useEffect(() => {\n        if (!clock) {\n            let newClock = new AudioContext();\n            setClock(newClock);\n        } \n        \n        if (Math.random() > 0.5) {\n            deckOneGlow += 10;\n            if (deckOneGlow >= 360) deckOneGlow = 0;\n        } else {\n            deckTwoGlow += 10;\n            if (deckTwoGlow >= 360) deckTwoGlow = 0;\n        }\n    })\n\n    useEffect(() => {\n        function LoadTrack() {\n            if (nextSongInQueue() !== null) {\n                console.log(\"next song in queue was not null\");\n                if ((deck1BPM == 0) && (deck1Song == '')) {\n                    loadTrackA();\n                } else if ((deck2BPM == 0) && (deck2Song == '')) {\n                    loadTrackB();\n                }\n            } else {\n                console.log(\"got next song in queue to be null\");\n            }\n        }\n        LoadTrack();\n    })\n\n    function loadTrackA() {\n        let newSong = loadTrack();\n        setDeck1prepared(false);\n        setDeck1Playing(false);\n        setDeck1remove(false);\n        if (newSong !== null) {\n            if (!newSong.songAnalysis.analysis) {\n                console.log(\"CASE A\", newSong);\n            } else {\n                console.log(\"CASE B\", newSong);\n            }\n            setDeck1BPM(Math.round(newSong.songAnalysis.analysis.tempo)) // terribly sus\n            let newvol = (newSong.songAnalysis.analysis.loudness / equalizedGainVal).toPrecision(5);\n            console.log(\"DECK A NEW VOLUME >>>>>>>>>>>>>>>>\", newvol);\n            setdeck1vol(newvol);\n            if (deck2Song === '') {\n                setDeck1playback(1);\n            } else {\n                if (deck2BPM !== 0) {\n                    let ratioPB = (deck2BPM / newSong.songAnalysis.analysis.tempo).toPrecision(5);\n                    setDeck1playback(ratioPB);\n                } else {\n                    setDeck1playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck A\";\n            newThought(think);\n            setDeck1Song(newSong);\n        }\n    }\n\n    function loadTrackB() {\n        let newSong = loadTrack();\n        setDeck2prepared(false);\n        setDeck2Playing(false);\n        setDeck2remove(false);\n        if (newSong !== null) {\n            \n\n            // EITHER IS newSong.songAnalysis || newSOng.songAnalysis.analysis\n            if (!newSong.songAnalysis.analysis) {\n                console.log(\"CASE A\", newSong);\n            } else {\n                console.log(\"CASE B\", newSong);\n            }\n\n            setDeck2BPM(Math.round(newSong.songAnalysis.analysis.tempo)) // terribly sus\n            let newvol = (newSong.songAnalysis.analysis.loudness / equalizedGainVal).toPrecision(5);\n            // console.log(\"DECK B NEW VOLUME >>>>>>>>>>>>>>>>\", newvol);\n            setdeck2vol(newvol);\n\n            if (deck1Song === '') {\n                setDeck2playback(1);\n            } else {\n                if (deck1BPM !== 0) {\n                    let ratio = (deck1BPM / Math.round(newSong.songAnalysis.analysis.tempo)).toPrecision(5);\n                    setDeck2playback(ratio);\n                } else {\n                    setDeck2playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck B\";\n            newThought(think);\n            setDeck2Song(newSong)\n        } else {\n            console.log(\"[WARNING] new song was null\");\n        }\n    }\n\n    function deckOneReady() {\n        if (!deck1prepared) {\n            setDeck1prepared(true);\n            if (!deck2Playing) {\n                setDeck1Playing(true);\n            }\n        }\n    }\n\n    function deckTwoReady() {\n        if (!deck2prepared) {\n            setDeck2prepared(true);\n            if (!deck1Playing) {\n                setDeck2Playing(true);\n            }\n        }\n    }\n\n    function playTrackTwo() {\n        if (deck2prepared) {\n            setDeck2Playing(true);\n            setDeck2prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 2;\n                mainTrack = 1;\n            }\n        }\n    }\n\n    function playTrackOne() {\n        if (deck1prepared) {\n            setDeck1Playing(true);\n            setDeck1prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 1;\n                mainTrack = 1;\n            }\n\n        }\n    }\n\n    function hitBarD1() {\n        deck1lastBar = clock.currentTime;\n        if (deck2Playing) {\n            setDeck1offset(deck2lastBar - deck1lastBar);\n        }\n    }\n\n    function hitBarD2() {\n        deck2lastBar = clock.currentTime;\n        if (deck1Playing) {\n            setDeck2offset(deck1lastBar - deck2lastBar);\n        }\n    }\n\n    function changeTrackA() {\n        mainTrack = 2;\n        setDeck2playback(1);\n        loadTrackA();\n    }\n\n    function changeTrackB() {\n        mainTrack = 1;\n        setDeck1playback(1);\n        loadTrackB();\n    }\n\n    function takeOutA() {\n        if (deck1Playing) setDeck1remove(true);\n        \n    }\n\n    function takeOutB() {\n        if (deck2Playing) setDeck2remove(true);\n    }\n\n    return (\n        <>\n            <div className={\"djboard\"}>\n                <div className={\"boardpanel\"} style={deck1Playing ? { boxShadow: `0 3px 100px hsla(${deckOneGlow}, 100%, 64%, 0.302)` } : { boxShadow: `0 0 0 hsla(${deckOneGlow}, 100%, 64%, 0.302)` }}>\n                    <h3>DECK A</h3>\n                    {deck1Song !== '' && <Deck\n                        \n                        thisSong={deck1Song.songURL}\n                        songName={deck1Song.songName}\n                        songArtist={deck1Song.songArtists[0].name}\n                        songImage={deck1Song.trackImage}\n                        songAnalysis={deck1Song.songAnalysis}\n                        \n                        playbackRate={deck1playback}\n                        prepared={deckOneReady}\n                        play={deck1Playing}\n                        startTime={deck1startTime}\n                        playOtherTrack={playTrackTwo}\n                        hitBar={hitBarD1}\n                        \n                        offset={deck1offset}\n                        deckName={\"Deck A\"}\n                        finished={changeTrackA}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 1}\n                        otherReady={deckTwoReady}\n                        waveformID={\"waveformA\"}\n                        bpm={deck1BPM}\n                        newThought={newThought}\n                        shouldRemove={deck1remove}\n                        removeOther={takeOutB}\n                        otherPlaying={deck2Playing}\n\n                        masterPlay={masterPlay}\n                    />\n                    }\n\n                </div>\n                <div className={\"boardpanel\"} style={deck2Playing ? { boxShadow: `0 3px 100px hsla(${deckTwoGlow}, 100%, 64%, 0.302)` } : { boxShadow: `0 0 0 hsla(${deckTwoGlow}, 100%, 64%, 0.302)` }}>\n                    <h3 style={{ textAlign: 'right' }}>DECK B</h3>\n                    {deck2Song !== '' && <Deck\n                        thisSong={deck2Song.songURL}\n                        songName={deck2Song.songName}\n                        songArtist={deck2Song.songArtists[0].name}\n                        songImage={deck2Song.trackImage}\n                        songAnalysis={deck2Song.songAnalysis}\n                        \n                        playbackRate={deck2playback}\n                        prepared={deckTwoReady}\n                        play={deck2Playing}\n                        startTime={deck2startTime}\n                        playOtherTrack={playTrackOne}\n                        hitBar={hitBarD2}\n                        offset={deck2offset}\n                        deckName={\"Deck B\"}\n                        finished={changeTrackB}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 2}\n                        otherReady={deckOneReady}\n                        waveformID={\"waveformB\"}\n                        bpm={deck2BPM}\n                        newThought={newThought}\n                        shouldRemove={deck2remove}\n                        removeOther={takeOutA}\n                        otherPlaying={deck1Playing}\n\n                        masterPlay={masterPlay}\n                    />}\n                </div>\n            </div>\n        </>\n    );\n}","import React, { useState } from 'react';\nimport TrackSelector from \"./TrackSelector\";\nimport TrackPlayer from \"./TrackPlayer\";\nimport QueueBox from \"./frontend_components/Queue\";\nimport Brain from \"./Brain\";\nimport axios from 'axios';\nimport MixConfig from './frontend_components/MixConfig';\n\nlet tracklist = [];\nlet upcomingSongs = [];\nlet alreadyPlayed = [];\n\nconst addSongRefURL = 'http://localhost:8080/addReference'\n\n// --- Global Functions ---\nexport function trackAlreadyIn(songID) { // todo converting this\n    for (const trackObj of tracklist) {\n        if (trackObj.songID === songID) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function loadTrack() {\n    let nextSong = null;\n    if (upcomingSongs.length !== 0) {\n        nextSong = upcomingSongs[0].body;\n        alreadyPlayed.push(nextSong);\n        upcomingSongs.shift();\n    }\n    return nextSong;\n}\n\nexport function nextSongInQueue() {\n    return upcomingSongs[0] || null;\n}\n\nexport function tracklistSize() {\n    return tracklist.length;\n}\n\nexport const thoughtType = {\n    NEUTRAL: 1,\n    SUCCESS: 2,\n    FAILURE: 3,\n    MIX: 4\n}\n\nlet currMixType = null;\n\nexport default function Mixbot() {\n    const [thoughts, setThoughts] = useState([]);\n    const [mixChosen, setMixChosen] = useState(false);\n    const [masterPlay, setMasterPlay] = useState(true);\n\n    function newThought(input, type = thoughtType.NEUTRAL) {\n        let shouldShow = true;\n        if (thoughts.length > 0 && thoughts[0].body === input) {\n            shouldShow = false;\n        }\n        setThoughts([{ id: \"THOUGHT-\" + thoughts.length, body: input, type: type, display: shouldShow }, ...thoughts]);\n    }\n\n    /**\n     * \n     * @param {*} songName: name of song\n     * @param {*} songArtists : array of artists of song\n     * @param {*} duration_ms: duration in ms \n     * @param {*} songURL: url to the temp reference link \n     * @param {*} analysis: raw spotify analysis \n     * @param {*} trackImage: img of album art \n     * @param {*} songID:  ID OF THE SPOTIFY SONG\n     * @param {*} videoID:  ID OF THE CORRESPONDING YT ID\n     * @param {boolean} fromDatabase: true if fetched yt id from database\n     */\n    async function addToQueue(songName, songArtists, duration_ms, songURL, analysis, trackImage, songID, videoID, fromDatabase) {\n        console.log(\"Called addToQueue for\", songName);\n        if (trackAlreadyIn(songID)) {\n            console.log(songName, \" was already in tracklist!\");\n            return;\n        }\n\n        if (analysis !== \"NOTFOUND\") {\n            if (!fromDatabase) {\n                console.log(\"Not in db yet, adding it...\");\n                let correctedArtists = [];\n                songArtists.forEach(artist => correctedArtists.push(artist.name));\n\n                let songRefEntry = {\n                    songID: songID, // spotify id\n                    videoID: videoID, // youtube videoID\n                    name: songName,\n                    artists: correctedArtists,\n                    duration: duration_ms,\n                }\n                // addSongRefDB(songRefEntry);\n            }\n        } else {\n            console.log(\"analysis was not found!\");\n        }\n\n        const newSong = {\n            songName: songName,\n            songArtists: songArtists,\n            duration_ms: duration_ms,\n            songURL: songURL,\n            songAnalysis: analysis,\n            trackImage: trackImage\n        }\n        console.log(\"added new song:\", fromDatabase)\n        // console.log(\">>>(MIXBOT): NEW SONG IS:\", newSong);\n        // console.log(\">>>(MIXBOT): ANALYSIS:\", analysis);\n        let packageSong = { id: \"tracklist\" + tracklist.length, body: newSong, songID: songID }\n        console.log(\"packaged song\");\n        // console.log(\">>>(MIXBOT): PACKAGED SONG:\", packageSong);\n        tracklist.push(packageSong);\n        \n        // console.log(\">>>(MIXBOT): ADDED TO TRACKLIST:\", tracklist);\n        upcomingSongs.push(packageSong);\n        console.log(\"pushed to tracklist and upcoming songs\");\n        // console.log(\">>>(MIXBOT): ADDED TO UPCOMING SONGS:\", upcomingSongs);\n        const think = `Added ${songName} to the tracklist`;\n        // console.log(\">>>(MIXBOT): ABOUT TO THINK:\", think);\n        newThought(think, thoughtType.NEUTRAL);\n        console.log(\"reached end of function\");\n    }\n\n    // function addSongRefDB(entry) {\n    //     axios.get(addSongRefURL, {\n    //         params: { data: entry }\n    //     });\n    // }\n\n    function choseMix(mixType) {\n        const think = \"Selected \" + mixType + \", beginning mix\";\n        newThought(think, thoughtType.SUCCESS);\n        currMixType = mixType;\n        setMixChosen(true);\n    }\n\n    function hitMasterPlay() {\n        console.log(\"hit master play\");\n        setMasterPlay(!masterPlay);\n        return masterPlay;\n    }\n\n    return (\n        <>\n            <div className=\"mixbot-body\">\n                <TrackPlayer newThought={newThought} masterPlay={masterPlay} />\n                <div className=\"mixbot-dropdowns\">\n                    <Brain decisions={thoughts} mixType={currMixType} />\n                    <QueueBox items={tracklist} />\n                    <MixConfig hitPause={hitMasterPlay} />\n                </div>\n            </div>\n            <div style={{ display: mixChosen ? 'none' : 'inherit' }}>\n                <TrackSelector\n                    addToQueue={addToQueue}\n                    addMoreSongs={upcomingSongs.length < 1}\n                    newThought={newThought}\n                    mixChosen={choseMix}\n                />\n            </div>\n\n        </>\n    )\n}\n","import React from 'react';\n//import '../css_files/Queue.scss';\n\nconst QueueBox = props => {\n    return (\n        <>\n            {props.items.length !== 0 &&\n                <div className=\"queue-header\">\n            \n                    <h2>TRACKLIST</h2>\n                    <div className=\"queue\" style={{ flexBasis: 'content', flexGrow: 1 }}>\n                        {\n                            props.items.map((item, idx) =>\n                                <div className={\"entry\"} key={item.id} style={{ flexGrow: 1 }}>\n                                    <p key={item.id + \"text\"}>{item.body.songName}</p>\n                                </div>)\n                        }\n                    </div>\n                </div>\n            }\n            </>\n    );\n}\n\nexport default QueueBox;","import React from 'react'\nimport './css_files/Queue.scss';\nimport { thoughtType } from './Mixbot';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport default function Brain({ decisions, mixType }) {\n\n    const entryColor = type => {\n        let color = '#7f7b80';\n        switch (type) {\n            case thoughtType.SUCCESS:\n                color = '#48e26f';\n                break;\n            case thoughtType.FAILURE:\n                color = '#e24848';\n                break;\n            case thoughtType.MIX:\n                color = 'tomato';\n                break;\n            default:\n                break;\n        }\n        \n        return color;\n    }\n\n    return (\n        <div className=\"queue-header\" style={{ flexGrow: 1 }}>\n            <h2>MIXBOT BRAIN // {mixType && mixType}</h2>\n            <div className=\"queue\">\n                {decisions.map(thought => (\n                    <div key={uuidv4()}>\n                        {thought.display && <div className={\"entry\"}>\n                            <p style={{ color: `${entryColor(thought.type)}` }}>{thought.body}</p>\n                        </div>}\n                </div>))}\n            </div>\n        </div>\n    )\n}\n","import React, {useState} from 'react'\n\n\nexport default function MixConfig({ hitPause }) {\n    const [isPaused, setisPaused] = useState(false);\n    function playPause() {\n        setisPaused(hitPause());\n    }\n\n    return (\n        <div className=\"queue-header\" style={{ flexGrow: 1 }}>\n            <h2>MIX SETTINGS</h2>\n            <div className=\"queue\">\n                <div className={\"entry\"}>\n                    <button onClick={() => playPause()}>{isPaused ? \"PLAY\" : \"PAUSE\"}</button> \n                    <p>Mix Lengths (WIP)</p>\n                    <p>Master Volume (WIP)</p>\n                    <p>Current Mix (WIP)</p>\n                </div>\n            </div>\n        </div>\n    )\n}\n","import React, {useState, useEffect} from 'react';\nimport './css_files/App.scss';\nimport UpdateMixBot from './frontend_components/UpdateMixBot';\nimport { Gateway } from './helper_classes/Gateway';\nimport Mixbot from './Mixbot';\n\nconst version = \"0.1\";\n\nfunction App() {\n    const [updateAvailable, setUpdateAvailable] = useState(null);\n    const [updateContent, setUpdateContent] = useState(null);\n\n    useEffect(() => {\n        async function checkForUpdate() {\n            const gateway = new Gateway();\n            console.log(\"Checking for update...\");\n            let newestVersion = await gateway.checkForUpdate(version);\n            console.log(\"Checking for update... GOT\", newestVersion);\n            let needUpdate = version !== newestVersion.version;\n            console.log(needUpdate);\n            if (needUpdate) {\n                setUpdateContent(newestVersion.newFeatures);\n                setUpdateAvailable(true);\n            } else {\n                setUpdateAvailable(false);\n            }\n        }\n        checkForUpdate();\n    }, [])\n\n    function dontCare() {\n        setUpdateAvailable(false);\n    }\n\n    return(\n        <div className={\"body\"}>\n            <div className={\"title\"}>\n                <h1>MIXBOT</h1>\n                <div className={\"credits\"}>\n                    <h3>An Open Source project by Parssa Kyanzadeh</h3> \n                 </div>\n            </div>\n            {updateAvailable != null ? updateAvailable ? <UpdateMixBot details={updateContent} dontCare={dontCare}/> :<Mixbot/> : null}            \n        </div>\n    );\n}\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}